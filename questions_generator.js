// questions_generator.js
// Runs at start if generator toggled in CONFIG.QOL.generatePlaceholdersWhenMissing
// It mutates the QUESTIONS object (loaded from questions.json) to ensure each topic has the requested number of items.

(function(window){
  window.QuestionsGenerator = {
    generateIfNeeded: function(QUESTIONS){
      if(!CONFIG.QOL.generatePlaceholdersWhenMissing) return QUESTIONS;
      const targets = CONFIG.topicTargetCounts || {};
      const topics = CONFIG.topics;
      topics.forEach(topic=>{
        const target = targets[topic] || 100;
        QUESTIONS[topic] = QUESTIONS[topic] || [];
        const current = QUESTIONS[topic].length;
        const need = target - current;
        if(need<=0) return;
        // Generate 'need' templated items depending on topic patterns
        for(let i=0;i<need;i++){
          const item = generateTemplateFor(topic, QUESTIONS[topic].length + 1);
          QUESTIONS[topic].push(item);
        }
      });
      return QUESTIONS;
    }
  };

  // helper to generate template items per topic
  function generateTemplateFor(topic, index){
    // simple, high-quality templates per category
    if(topic.includes("acid")){
      // alternate binary and oxyacids
      if(index % 2 === 0){
        const halogens = ["Cl","Br","I","F"];
        const x = halogens[index % halogens.length];
        return {
          prompt: `Name H${x} (aq)`,
          canonicalAnswer: `hydro${elementName(x).toLowerCase()} acid`,
          explanation: `Binary acid from ${x}`
        };
      } else {
        const ox = ["SO4","NO3","PO4","CO3"];
        const oxi = ox[index % ox.length];
        return {
          prompt: `Name H${oxi} (aq)`,
          canonicalAnswer: `${polyName(oxi)} acid`,
          explanation: `Oxoacid from ${oxi}`
        };
      }
    }

    if(topic.includes("hydrocarbon")){
      const prefixes = ["meth","eth","prop","but","pent","hex","hept","oct","non","dec"];
      const suffixes = ["ane","ene","yne"];
      const p = prefixes[index % prefixes.length];
      const s = suffixes[index % suffixes.length];
      const carbons = index % 10 + 1;
      const formula = `C${carbons}H${(carbons*2)+ (s==="ane"?2: (s==="ene"?0:-2))}`;
      return {
        prompt: `Name ${formula}`,
        canonicalAnswer: `${p}${s}`,
        explanation: `Hydrocarbon (${carbons} C) - ${p}${s}`
      };
    }

    if(topic.includes("mega") || topic.includes("mixed") || topic.includes("mega_mixed")){
      // mix ionic with roman numerals and covalent
      if(index % 3 === 0){
        const metals = [{sym:"Fe",name:"iron",oxi: index%2===0?3:2}, {sym:"Cu",name:"copper",oxi:2}];
        const m = metals[index % metals.length];
        const anion = ["Cl","Br","O","S"][index%4];
        const formula = `${m.sym}${(m.oxi>1)?(m.oxi):""}${anion}${ m.oxi>1? "":"" }`;
        // give a roman numeral if oxi>1
        const roman = m.oxi>1?`(${toRoman(m.oxi)})`:"";
        return {
          prompt: `Name ${m.sym}${anion}`,
          canonicalAnswer: `${m.name}${roman} ${anion==='O'?'oxide': anion==='Cl'?'chloride':'anion'}`,
          explanation: `Ionic compound with metal requiring roman numeral`
        };
      } else {
        // covalent
        const a = ["carbon","nitrogen","sulfur","phosphorus"][index%4];
        const b = ["oxygen","fluorine","chlorine","bromine"][index%4];
        const na = (index%3)+1;
        const nb = ((index+1)%3)+1;
        const formula=`${elementSym(a)}${na}${elementSym(b)}${nb}`;
        return {
          prompt: `Name ${formula}`,
          canonicalAnswer: `${numPrefix(na)}${a} ${numPrefix(nb)}${b}`,
          explanation: `Covalent naming`
        };
      }
    }

    // Generic fallback: simple Q->A placeholder
    return {
      prompt: `Practice item ${topic} #${index}`,
      canonicalAnswer: `Answer ${index}`,
      explanation: `Autogenerated placeholder for ${topic}`
    };
  }

  // small helpers (element name lookup limited)
  function elementName(sym){
    const map = {Cl:"chloride",Br:"bromide",I:"iodide",F:"fluoride"};
    return map[sym] ? map[sym].replace("ide","") : sym;
  }
  function polyName(oxi){
    const map = {"SO4":"sulfuric","NO3":"nitric","PO4":"phosphoric","CO3":"carbonic"};
    return map[oxi] || (oxi+"-acid");
  }
  function toRoman(num){
    const map=[ ['X',10],['IX',9],['V',5],['IV',4],['I',1] ];
    let s="";
    for(const [r,v] of map){ while(num>=v){ s+=r; num-=v; } }
    return s;
  }
  function numPrefix(n){
    const prefixes=["","mono","di","tri","tetra","penta","hexa"];
    return prefixes[n]||n;
  }
  function elementSym(name){
    const m={carbon:"C",nitrogen:"N",oxygen:"O",fluorine:"F",chlorine:"Cl",bromine:"Br",sulfur:"S",phosphorus:"P"};
    return m[name]||name.slice(0,1).toUpperCase();
  }
})(window);
